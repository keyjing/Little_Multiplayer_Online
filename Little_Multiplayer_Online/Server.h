#ifndef _Server_h
#define _Server_h

#include "Multicast.h"
#include<thread>
#include<mutex>
#include<queue>

#define MAX_CONNECT			10				// 最大控制数
#define MAX_BACKLOG			20				// 监听队列数量
#define SERV_PORT			1234			// 服务器端口
#define SERV_MC_ADDR		"230.0.0.1"		// 多播组地址
#define SERV_MC_PORT		2333			// 多播组端口

#define SERV_SUCCESS		0
#define SERV_ERROR_SOCK		-1
#define SERV_ERROR_NO_MC	-2

#define MY_MSG_BOARD		-1				// 数据边界

class ControlOption				// Interface: 服务器的控制命令产生
{
public:
	virtual char createOpt() = 0;
};

class Server
{
	char name[BUFSIZE] = { 0 };				// 服务器名
	int clients = 0;						// 控制的客户端数，包括 hostReserve
	//int hostReserve = 1;					// 保留的客户端数，默认保留一个为服务器专用
	SOCKET clientsSock[MAX_CONNECT] = { INVALID_SOCKET };	// 与客户端连接的套接字
	//char options[MAX_CONNECT];				// 各个客服端的操作指令，默认下标 0 为 Server 发布的控制指令
	ControlOption* ctrlOpt = nullptr;		// Server控制指令产生的接口

	char msg[BUFSIZE];
	int end = 0;
	std::mutex mt_msg;
	std::condition_variable cond_msg;

	bool signal_send;
	std::mutex mt_signal;
	std::condition_variable cond_signal;

	volatile bool running;
	int thds_cnt;
	std::mutex mt_thds;
	std::condition_variable cond_thds;

	static void myClock_thd(Server* sp);
	static void recv_thd(Server* sp);
	static void send_thd(Server* sp);

public:
	Server(const char* _name, int _clients);

	~Server();

	int waitConnect(bool openMulticast, bool showLog = false);

	void startWork();

	void stop() {  }	//向工作线程发出停止信号
};

#endif
